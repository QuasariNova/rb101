1.Let's do some "ASCII Art" (a stone-age form of nerd artwork from back in the days before computers had video screens).

For this practice problem, write a one-line program that creates the following output 10 times, with the subsequent line indented 1 space to the right:

  The Flintstones Rock!
  The Flintstones Rock!
    The Flintstones Rock!

----

  10.times { |n| puts "#{' ' * n}The Flintstones Rock!"}

================================================================================

The result of the following statement will be an error:

  puts "the value of 40 + 2 is " + (40 + 2)

Why is this and what are two possible ways to fix this?

----

40 + 2 evaluates as an integer 42, which is not able to be concatenated with a
string. Two ways to fix this are:

  puts "the value of 40 + 2 is " + (40 + 2).to_s
  puts "the value of 40 + 2 is #{40 + 2}"

================================================================================

3.Alan wrote the following method, which was intended to show all of the factors of the input number:

def factors(number)
  divisor = number
  factors = []
  begin
    factors << number / divisor if number % divisor == 0
    divisor -= 1
  end until divisor == 0
  factors
end

Alyssa noticed that this will fail if the input is 0, or a negative number, and
asked Alan to change the loop. How can you make this work without using the
begin/end until construct? Note that we're not looking to find the factors for
0 or negative numbers, but we just want to handle it gracefully instead of
raising an exception or going into an infinite loop.

Bonus 1
What is the purpose of the number % divisor == 0 ?

Bonus 2
What is the purpose of the second-to-last line (line 8) in the method (the
factors before the method's end)?

----
Not using begin/end until loop:

  def factors(number)
    divisor = number
    factors = []
    while divisor > 0
      factors << number / divisor if number % divisor == 0
      divisor -= 1
    end
    factors
  end

Bonuses:
  1. To check if divisor fully divides into number without a remainder aka is
    really a factor.

  2. It is used to implicitly return factors.

================================================================================

4.Alyssa was asked to write an implementation of a rolling buffer. Elements are added to the rolling buffer and if the buffer becomes full, then new elements that are added will displace the oldest elements in the buffer.

She wrote two implementations saying, "Take your pick. Do you like << or + for modifying the buffer?". Is there a difference between the two, other than what operator she chose to use to concatenate an element to the buffer?

  def rolling_buffer1(buffer, max_buffer_size, new_element)
    buffer << new_element
    buffer.shift if buffer.size > max_buffer_size
    buffer
  end

  def rolling_buffer2(input_array, max_buffer_size, new_element)
    buffer = input_array + [new_element]
    buffer.shift if buffer.size > max_buffer_size
    buffer
  end

----

If you use << it will mutate the buffer passed to it. If you use + for
modifying it, it will not mutate input_array. Both have their uses, if you need
to keep the value of the previous buffer + is better, otherwise << is fine.

================================================================================

5.Alyssa asked Ben to write up a basic implementation of a Fibonacci
calculator. A user passes in two numbers, and the calculator will keep
computing the sequence until some limit is reached.

Ben coded up this implementation but complained that as soon as he ran it, he
got an error. Something about the limit variable. What's wrong with the code?

limit = 15

def fib(first_num, second_num)
  while first_num + second_num < limit
    sum = first_num + second_num
    first_num = second_num
    second_num = sum
  end
  sum
end

result = fib(0, 1)
puts "result is #{result}"

How would you fix this so that it works?

----

This is happening, because the fib method has no access to local variable
limit. This is due to scoping. If you change limit to a constant it should be
fine. Alternatively, you could add an argument to fib for limit as well.

================================================================================

What is the output of the following code?

  answer = 42

  def mess_with_it(some_number)
    some_number += 8
  end

  new_answer = mess_with_it(answer)

  p answer - 8

----

Because integers are immutable, mess_with_it will not mutate answer. p will
print 34.
