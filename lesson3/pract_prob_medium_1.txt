1.Let's do some "ASCII Art" (a stone-age form of nerd artwork from back in the days before computers had video screens).

For this practice problem, write a one-line program that creates the following output 10 times, with the subsequent line indented 1 space to the right:

  The Flintstones Rock!
  The Flintstones Rock!
    The Flintstones Rock!

----

  10.times { |n| puts "#{' ' * n}The Flintstones Rock!"}

================================================================================

The result of the following statement will be an error:

  puts "the value of 40 + 2 is " + (40 + 2)

Why is this and what are two possible ways to fix this?

----

40 + 2 evaluates as an integer 42, which is not able to be concatenated with a
string. Two ways to fix this are:

  puts "the value of 40 + 2 is " + (40 + 2).to_s
  puts "the value of 40 + 2 is #{40 + 2}"

================================================================================

3.Alan wrote the following method, which was intended to show all of the factors of the input number:

def factors(number)
  divisor = number
  factors = []
  begin
    factors << number / divisor if number % divisor == 0
    divisor -= 1
  end until divisor == 0
  factors
end

Alyssa noticed that this will fail if the input is 0, or a negative number, and
asked Alan to change the loop. How can you make this work without using the
begin/end until construct? Note that we're not looking to find the factors for
0 or negative numbers, but we just want to handle it gracefully instead of
raising an exception or going into an infinite loop.

Bonus 1
What is the purpose of the number % divisor == 0 ?

Bonus 2
What is the purpose of the second-to-last line (line 8) in the method (the
factors before the method's end)?

----
Not using begin/end until loop:

  def factors(number)
    divisor = number
    factors = []
    while divisor > 0
      factors << number / divisor if number % divisor == 0
      divisor -= 1
    end
    factors
  end

Bonuses:
  1. To check if divisor fully divides into number without a remainder aka is
    really a factor.

  2. It is used to implicitly return factors.

================================================================================

4.Alyssa was asked to write an implementation of a rolling buffer. Elements are added to the rolling buffer and if the buffer becomes full, then new elements that are added will displace the oldest elements in the buffer.

She wrote two implementations saying, "Take your pick. Do you like << or + for modifying the buffer?". Is there a difference between the two, other than what operator she chose to use to concatenate an element to the buffer?

  def rolling_buffer1(buffer, max_buffer_size, new_element)
    buffer << new_element
    buffer.shift if buffer.size > max_buffer_size
    buffer
  end

  def rolling_buffer2(input_array, max_buffer_size, new_element)
    buffer = input_array + [new_element]
    buffer.shift if buffer.size > max_buffer_size
    buffer
  end

----

If you use << it will mutate the buffer passed to it. If you use + for
modifying it, it will not mutate input_array. Both have their uses, if you need
to keep the value of the previous buffer + is better, otherwise << is fine.
